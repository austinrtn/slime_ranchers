const std = @import("std");
const metadata = @import("SystemMetadata");
const Phases = @import("Phases");
const FileWriter = @import("FileWriter.zig").FileWriter;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Get project directory from command line
    var arg_iter = try std.process.argsWithAllocator(allocator);
    defer arg_iter.deinit();

    // Skip program name
    _ = arg_iter.next();

    const project_dir = arg_iter.next() orelse {
        std.debug.print("Usage: system-seq-gen <project-directory>\n", .{});
        return error.MissingProjectDir;
    };

    try generateSystemSequence(allocator, project_dir);
}

fn generateSystemSequence(allocator: std.mem.Allocator, project_dir: []const u8) !void {
    std.debug.print("Generating SystemSequence.zig...\n", .{});

    // Build execution order by phase
    var execution_order: std.ArrayList(usize) = .empty;
    defer execution_order.deinit(allocator);

    // Group systems by phase
    for (Phases.phase_sequence) |phase| {
        const phase_name = @tagName(phase);

        // Collect systems in this phase
        var phase_systems: std.ArrayList(usize) = .empty;
        defer phase_systems.deinit(allocator);

        for (metadata.all_metadata, 0..) |sys, idx| {
            if (std.mem.eql(u8, sys.phase, phase_name)) {
                try phase_systems.append(allocator, idx);
            }
        }

        // Sort systems within phase using topological sort
        const sorted = try topologicalSort(allocator, phase_systems.items, metadata.all_metadata);
        defer allocator.free(sorted);

        // Add to execution order
        for (sorted) |idx| {
            try execution_order.append(allocator, idx);
        }
    }

    // Generate the file
    const registries_path = try std.fs.path.join(allocator, &.{ project_dir, "src", "registries" });
    defer allocator.free(registries_path);

    const output_path = try std.fs.path.join(allocator, &.{ registries_path, "SystemSequence.zig" });
    defer allocator.free(output_path);

    var file_writer: FileWriter = .{ .filePath = output_path };
    defer file_writer.deinit(allocator);

    // File header
    try file_writer.writeLine(allocator, "// Auto-generated file - DO NOT EDIT");
    try file_writer.writeLine(allocator, "// Generated by system_sequence_generator.zig");
    try file_writer.writeLine(allocator, "");
    try file_writer.writeLine(allocator, "/// Pre-computed system execution order sorted by phase and dependencies");
    try file_writer.write(allocator, "pub const execution_order: []const usize = &.{");

    // Write execution order
    for (execution_order.items, 0..) |idx, i| {
        if (i == 0) {
            try file_writer.write(allocator, " ");
        } else {
            try file_writer.write(allocator, ", ");
        }
        const idx_str = try std.fmt.allocPrint(allocator, "{d}", .{idx});
        defer allocator.free(idx_str);
        try file_writer.write(allocator, idx_str);
    }

    try file_writer.writeLine(allocator, " };");
    try file_writer.writeLine(allocator, "");

    // Write phase boundaries for debugging
    try file_writer.writeLine(allocator, "/// System indices grouped by phase (for debugging)");
    try file_writer.writeLine(allocator, "pub const phase_boundaries = struct {");

    var offset: usize = 0;
    for (Phases.phase_sequence) |phase| {
        const phase_name = @tagName(phase);

        // Count systems in this phase
        var count: usize = 0;
        for (metadata.all_metadata) |sys| {
            if (std.mem.eql(u8, sys.phase, phase_name)) {
                count += 1;
            }
        }

        const field_line = try std.fmt.allocPrint(allocator, "    pub const {s} = .{{ .start = {d}, .end = {d} }};", .{ phase_name, offset, offset + count });
        defer allocator.free(field_line);
        try file_writer.writeLine(allocator, field_line);

        offset += count;
    }

    try file_writer.writeLine(allocator, "};");

    // Write to file
    try file_writer.saveFile();

    std.debug.print("  Generated: {s}\n", .{output_path});
}

/// Topological sort with cycle detection
fn topologicalSort(allocator: std.mem.Allocator, indices: []const usize, systems: []const metadata.SystemMetadata) ![]usize {
    const n = indices.len;
    if (n == 0) return try allocator.alloc(usize, 0);

    // Build adjacency list (who depends on whom within this phase)
    var adj_list: std.ArrayList(std.ArrayList(usize)) = .empty;
    defer {
        for (adj_list.items) |*list| {
            list.deinit(allocator);
        }
        adj_list.deinit(allocator);
    }

    var in_degree = try allocator.alloc(usize, n);
    defer allocator.free(in_degree);
    @memset(in_degree, 0);

    for (0..n) |_| {
        const new_list: std.ArrayList(usize) = .empty;
        try adj_list.append(allocator, new_list);
    }

    // Build dependency graph
    for (indices, 0..) |idx_i, i| {
        const sys_i = systems[idx_i];

        for (indices, 0..) |idx_j, j| {
            if (i == j) continue;
            const sys_j = systems[idx_j];

            // Check if sys_i must run before sys_j
            var i_before_j = false;

            // Explicit runs_before
            for (sys_i.runs_before) |before| {
                if (std.mem.eql(u8, before, sys_j.name)) {
                    i_before_j = true;
                    break;
                }
            }

            // Explicit runs_after (sys_j runs after sys_i)
            if (!i_before_j) {
                for (sys_j.runs_after) |after| {
                    if (std.mem.eql(u8, after, sys_i.name)) {
                        i_before_j = true;
                        break;
                    }
                }
            }

            // Component dependency: sys_i writes what sys_j reads
            if (!i_before_j) {
                for (sys_i.writes) |write| {
                    for (sys_j.reads) |read| {
                        if (std.mem.eql(u8, write, read)) {
                            i_before_j = true;
                            break;
                        }
                    }
                    if (i_before_j) break;
                }
            }

            if (i_before_j) {
                try adj_list.items[i].append(allocator, j);
                in_degree[j] += 1;
            }
        }
    }

    // Kahn's algorithm for topological sort
    var queue: std.ArrayList(usize) = .empty;
    defer queue.deinit(allocator);

    var result: std.ArrayList(usize) = .empty;
    defer result.deinit(allocator);

    // Start with nodes that have no dependencies
    for (in_degree, 0..) |deg, i| {
        if (deg == 0) {
            try queue.append(allocator, i);
        }
    }

    while (queue.items.len > 0) {
        const current = queue.orderedRemove(0);
        try result.append(allocator, indices[current]);

        for (adj_list.items[current].items) |neighbor| {
            in_degree[neighbor] -= 1;
            if (in_degree[neighbor] == 0) {
                try queue.append(allocator, neighbor);
            }
        }
    }

    // Check for cycles
    if (result.items.len != n) {
        std.debug.print("  WARNING: Cycle detected in phase, falling back to input order\n", .{});
        // Fall back to original order
        return try allocator.dupe(usize, indices);
    }

    return try result.toOwnedSlice(allocator);
}
